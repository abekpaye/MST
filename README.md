# Assignment 3: Optimization of a City Transportation Network (Minimum Spanning Tree)
Aida Bekpayeva. 26.10.2025.

## Objective
The purpose of this project is to optimize a city’s transportation network by determining the minimum set of roads that connect all city districts at the lowest total construction cost.  
Two algorithms were implemented and analyzed:
- Prim’s Algorithm
- Kruskal’s Algorithm

---

##  Input Data Summary

The experiments were conducted on 28 graphs of varying sizes:

| Category | Graph Count | Vertices Range | Graph ids    |
|-----------|--------------|----------------|--------------|
| Small     | 5 graphs     | 5–30 vertices  | Graphs 1–5   |
| Medium    | 10 graphs    | 30–300 vertices | Graphs 6–15  |
| Large     | 10 graphs    | 300–1000 vertices | Graphs 16–25 |
| Extreme   | 3 graphs     | 1000–2000 vertices | Graphs 26–28 |

Input data was generated by python code.

Each graph was tested with both Prim’s and Kruskal’s algorithms.  
The following metrics were collected:
- Total cost of MST
- Number of operations 
- Execution time in milliseconds

---

## Algorithmic Overview

### Prim’s Algorithm
- Starts from a random vertex and grows the MST by repeatedly adding the lowest-weight edge that connects a visited vertex to an unvisited vertex.
- Efficient with dense graphs using adjacency lists and priority queues.
- Time complexity: O(E log V)

### Kruskal’s Algorithm
- Sorts all edges by weight and selects the smallest edges that do not form a cycle.
- Utilizes Union-Find (Disjoint Set Union) for cycle detection.
- More efficient with sparse graphs.
- Time complexity: O(E log E) (≈ O(E log V))

---

## Results Summary

| ID | Algorithm | Vertices | Total Cost | Operations Count | Execution Time (ms) |
|----|------------|-----------|-------------|------------------|---------------------|
| 1 | Prim | 10 | 341.0 | 10 | 1.2208 |
| 1 | Kruskal | 10 | 341.0 | 13 | 1.8282 |
| 2 | Prim | 20 | 646.0 | 30 | 0.1367 |
| 2 | Kruskal | 20 | 646.0 | 36 | 0.0758 |
| 3 | Prim | 25 | 787.0 | 38 | 0.1653 |
| 3 | Kruskal | 25 | 787.0 | 46 | 0.0731 |
| 4 | Prim | 10 | 348.0 | 16 | 0.0407 |
| 4 | Kruskal | 10 | 348.0 | 16 | 0.0227 |
| 5 | Prim | 22 | 794.0 | 27 | 0.0917 |
| 5 | Kruskal | 22 | 794.0 | 34 | 0.0610 |
| 6 | Prim | 169 | 5477.0 | 281 | 2.5122 |
| 6 | Kruskal | 169 | 5477.0 | 283 | 0.3491 |
| 7 | Prim | 126 | 3498.0 | 206 | 0.8440 |
| 7 | Kruskal | 126 | 3498.0 | 245 | 0.2565 |
| 8 | Prim | 158 | 4594.0 | 286 | 1.2181 |
| 8 | Kruskal | 158 | 4594.0 | 286 | 0.4285 |
| 9 | Prim | 56 | 1632.0 | 87 | 0.2403 |
| 9 | Kruskal | 56 | 1632.0 | 102 | 0.1248 |
| 10 | Prim | 51 | 1593.0 | 79 | 0.1811 |
| 10 | Kruskal | 51 | 1593.0 | 79 | 0.0973 |
| 11 | Prim | 185 | 6632.0 | 312 | 1.6960 |
| 11 | Kruskal | 185 | 6632.0 | 314 | 0.3827 |
| 12 | Prim | 239 | 8275.0 | 416 | 2.9054 |
| 12 | Kruskal | 239 | 8275.0 | 419 | 0.4872 |
| 13 | Prim | 86 | 2239.0 | 124 | 0.4226 |
| 13 | Kruskal | 86 | 2239.0 | 164 | 0.1800 |
| 14 | Prim | 226 | 7363.0 | 404 | 2.6430 |
| 14 | Kruskal | 226 | 7363.0 | 418 | 0.5568 |
| 15 | Prim | 287 | 9976.0 | 445 | 3.7254 |
| 15 | Kruskal | 287 | 9976.0 | 448 | 0.4232 |
| 16 | Prim | 434 | 13610.0 | 764 | 7.1993 |
| 16 | Kruskal | 434 | 13610.0 | 771 | 0.9177 |
| 17 | Prim | 941 | 27876.0 | 1842 | 35.4867 |
| 17 | Kruskal | 941 | 27876.0 | 1860 | 2.3337 |
| 18 | Prim | 483 | 15620.0 | 846 | 3.2921 |
| 18 | Kruskal | 483 | 15620.0 | 864 | 0.9317 |
| 19 | Prim | 598 | 20383.0 | 996 | 4.7572 |
| 19 | Kruskal | 598 | 20383.0 | 1003 | 1.0663 |
| 20 | Prim | 577 | 18938.0 | 1004 | 4.6709 |
| 20 | Kruskal | 577 | 18938.0 | 1011 | 0.9530 |
| 21 | Prim | 432 | 14188.0 | 754 | 2.7450 |
| 21 | Kruskal | 432 | 14188.0 | 773 | 0.6348 |
| 22 | Prim | 342 | 12422.0 | 512 | 1.4978 |
| 22 | Kruskal | 342 | 12422.0 | 518 | 0.4393 |
| 23 | Prim | 363 | 11233.0 | 640 | 1.9757 |
| 23 | Kruskal | 363 | 11233.0 | 649 | 0.5498 |
| 24 | Prim | 910 | 29401.0 | 1537 | 10.5985 |
| 24 | Kruskal | 910 | 29401.0 | 1561 | 1.5290 |
| 25 | Prim | 644 | 19591.0 | 1147 | 7.2048 |
| 25 | Kruskal | 644 | 19591.0 | 1159 | 1.0205 |
| 26 | Prim | 1099 | 33640.0 | 2068 | 22.9412 |
| 26 | Kruskal | 1099 | 33640.0 | 2069 | 1.6306 |
| 27 | Prim | 1547 | 53926.0 | 2500 | 51.1499 |
| 27 | Kruskal | 1547 | 53926.0 | 2505 | 1.5311 |
| 28 | Prim | 1447 | 47812.0 | 2469 | 43.5837 |
| 28 | Kruskal | 1447 | 47812.0 | 2473 | 1.6363 |


### Observations:
- Both algorithms produced identical MST total costs, confirming correctness.
- Kruskal’s algorithm consistently outperformed Prim’s in execution time for larger graphs.
- Prim’s algorithm performed better for small, dense graphs, due to reduced sorting overhead.

---

## Theory

| Criterion | Prim’s Algorithm | Kruskal’s Algorithm |
|------------|------------------|----------------------|
| **Graph Type Preference** | Dense | Sparse |
| **Data Structure Used** | Priority Queue (Heap) | Union-Find (Disjoint Sets) |
| **Complexity** | O(E log V) | O(E log E) |
| **Practical Performance** | Slower on large sparse graphs | Significantly faster on large datasets |
| **Implementation Difficulty** | Moderate | Slightly more complex (Union-Find needed) |

## In practice:

### Execution Time

- Small graphs (V < 100): both algorithms perform similarly.
- **Medium graphs (100–500): Kruskal’s is generally faster, since sorting edges is done once and the Union-Find structure efficiently merges sets.
- Large graphs (V > 500): Prim’s becomes slower due to numerous heap operations on many edges.

**Examples:**

| Graph ID | Vertices | Prim (ms) | Kruskal (ms) | Faster Algorithm |
|-----------|-----------|-----------|---------------|------------------|
| #27 | 1547 | 51.15 | 1.53 | Kruskal |
| #28 | 1447 | 43.58 | 1.63 | Kruskal |


### Operation Count

- Prim’s processes fewer edges (selective addition from visited vertices).
- Kruskal’s examines every edge after sorting, increasing the operation count slightly (~1–3% difference).
- However, due to simpler loops and no dynamic priority queue updates, Kruskal’s achieves better execution time in practice.

### Efficiency Nuances

- Prim’s Algorithm: heavily depends on graph representation — best results achieved using an adjacency list + binary heap.
- Kruskal’s Algorithm: performance mainly relies on sorting efficiency and the Union-Find implementation (path compression + rank balancing).

## Conclusions

1. Both algorithms produce the same MST results, ensuring correctness.
2. Prim’s algorithm is preferable for dense graphs or when adjacency lists are efficient.
3. Kruskal’s algorithm is better suited for sparse or large-scale networks.
4. Execution time grows linearly with edge count for Kruskal, while it grows more steeply for Prim.
5. Kruskal’s sorting phase is computationally heavy but amortized over large datasets.

## Recommended usage:
- Use Prim’s when graph is dense (many connections).
- Use Kruskal’s when graph is sparse (fewer connections, large networks).

---

## References
- GeeksForGeeks. Difference between Prim's and Kruskal's algorithm for MST. https://www.geeksforgeeks.org/dsa/difference-between-prims-and-kruskals-algorithm-for-mst/?utm_source
